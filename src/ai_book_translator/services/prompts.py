from __future__ import annotations
from typing import List, Any, Dict, Optional

# =========================
# STEP 1 — METADATA (UPLOAD / GLOBAL)
# =========================

METADATA_SYSTEM_PROMPT = (
    "Extract book metadata and return ONLY a single JSON object (no markdown, no extra text). "
    "The JSON must contain EXACTLY these keys and no others: "
    '"author(s)", "title", "language", "summary", "chapters". '
    'If a field is not present, use the EXACT string "not provided", '
    "EXCEPT for fields explicitly marked below as inferable or generatable. "
    '"author(s)" MUST be a single string of names separated by comma+space (", "), never an array. '
    '"chapters" MUST be a JSON object where each key is a chapter identifier string and each value is an object '
    'with two keys: "general" (a short 1-3 sentence summary) and "detailed" (a detailed short essay summary); '
    "if chapters cannot be inferred, output an empty object {}.\n\n"
    "IMPORTANT — INFERENCE & GENERATION RULES:\n"
    '- "language": MUST be inferred automatically from the document text if not explicitly stated. '
    'Use "not provided" ONLY if the language cannot be reliably identified.\n'
    '- "summary": MUST be generated by you if it is not explicitly present in the document. '
    'Use "not provided" ONLY if a summary cannot be generated due to insufficient or corrupted text.\n'
)

METADATA_USER_PROMPT_UPLOAD = "Return the metadata JSON for the uploaded document."

# Used only when schema-mode fails or returns unusable output:
METADATA_REPAIR_PROMPT = (
    "You MUST rewrite the content below into VALID JSON ONLY.\n"
    "This is a DATA REPAIR task, not a summarization or explanation task.\n\n"
    "OUTPUT REQUIREMENTS (MANDATORY):\n"
    "1. Output MUST be a single valid JSON object.\n"
    "2. Do NOT include any text before or after the JSON.\n"
    "3. Do NOT include markdown, comments, explanations, or formatting.\n\n"
    "JSON SCHEMA (YOU MUST FOLLOW EXACTLY):\n"
    "- The JSON object MUST contain EXACTLY the following 5 keys:\n"
    '  • "author(s)"\n'
    '  • "title"\n'
    '  • "language"\n'
    '  • "summary"\n'
    '  • "chapters"\n\n'
    "KEY CONSTRAINTS:\n"
    '- "author(s)":\n'
    "  • MUST be a SINGLE STRING\n"
    '  • MUST list author names separated by comma + space (", ")\n'
    "  • MUST NOT be a JSON array\n"
    '  • If authors are unknown, use the EXACT string "not provided"\n\n'
    '- "title":\n'
    "  • MUST be a STRING\n"
    '  • If title is unknown, use the EXACT string "not provided"\n\n'
    '- "language":\n'
    "  • MUST be a STRING\n"
    "  • MUST be inferred automatically from the document text if not explicitly stated. "
    '  • Use "not provided" ONLY if the language cannot be reliably identified.\n\n'
    '- "summary":\n'
    "  • MUST be a STRING\n"
    "  • Must be a paragraph summarizing the document\n"
    "  • If summary cannot be inferred, generate it on your own."
    'And only when it can\'t be generated because of reasons like document encding errors use the EXACT string "not provided"\n\n'
    '- "chapters":\n'
    "  • MUST be a JSON OBJECT (dictionary)\n"
    "  • Each KEY must be a chapter identifier (string)\n"
    '  • Each VALUE must be an OBJECT with exactly two keys: "general" (1-3 sentences) and "detailed" (short essay)\n'
    "  • MUST NOT be an array\n"
    "  • If chapters cannot be inferred, use an EMPTY OBJECT {}\n\n"
    "ADDITIONAL STRICT RULES:\n"
    "- NO additional keys are allowed (additionalProperties = false).\n"
    '- All values MUST be strings, except "chapters" which is an object of string → object.\n'
    "- Do NOT invent information for fields: title, authors, chapters.\n"
    "- Do NOT omit required keys.\n"
    "EXAMPLE OF A CORRECT RESPONSE (FORMAT ONLY):\n"
    "{\n"
    '  "author(s)": "Carl Gustav Jung",\n'
    '  "title": "Über die Psychologie des Unbewussten",\n'
    '  "language": "German",\n'
    '  "summary": "This work explores the structure and dynamics of the unconscious mind, introducing foundational concepts of analytical psychology such as archetypes, the collective unconscious, and symbolic interpretation of mythological and psychological material.",\n'
    '  "chapters": {\n'
    '    "Chapter 1": {\n'
    '      "general": "Introduction to the concept of the unconscious and its role in psychological life.",\n'
    '      "detailed": "Jung introduces the concept of the unconscious not as a mere repository of repressed memories, but as a dynamic and creative force..."\n'
    "    },\n"
    '    "Chapter 2": {\n'
    '      "general": "Analysis of mythological symbols and their psychological significance.",\n'
    '      "detailed": "In this chapter, the author examines various myths from different cultures to demonstrate the universality of certain symbols..."\n'
    "    }\n"
    "  }\n"
    "}\n\n"
    "INPUT TO REPAIR:\n"
)

# =========================
# STEP 1 — LOCAL LLM CHUNK SUMMARIZATION
# =========================

LOCAL_CHUNK_SUMMARY_SYSTEM_PROMPT = (
    "Summarize the provided chunk of a book. Be VERY brief. "
    "Output plain text only (no JSON)."
)


def build_local_chunk_summary_user_prompt(
    chunk_text: str,
    *,
    is_early_chunk: bool,
) -> str:
    extra = ""
    if is_early_chunk:
        extra = (
            "\n\nIf you can infer the book title and author(s), mention them. "
            "If you can infer a chapter list, mention it explicitly."
        )
    return f"Chunk text:\n{chunk_text}{extra}"


# =========================
# STEP 1 — SUMMARY OF SUMMARIES (LOCAL LLM)
# =========================

SUMMARY_OF_SUMMARIES_SYSTEM_PROMPT = (
    METADATA_SYSTEM_PROMPT
    + " The input is a list of chunk summaries, not the original document."
)


def build_summary_of_summaries_user_prompt(
    chunk_summaries: List[str],
) -> str:
    joined = "\n\n".join(f"- {s.strip()}" for s in chunk_summaries if s.strip())
    return (
        "Synthesize the following chunk summaries into the required metadata JSON.\n\n"
        f"Chunk summaries:\n{joined}"
    )


# =========================
# STEP 2 — TRANSLATION
# =========================


def build_translation_system_prompt(previous_tail: str) -> str:

    # TODO remove
    print("SYSTEM PROMPT 4 TRANSLATION -->", (
        "You are a professional book translator.\n"
        'Return STRICT JSON only: {"chapter": "...", "translation": "..."}.\n'
        'The "chapter" field MUST match the exact chapter key from the "Chapters Context".\n'
        "If you clearly detect the start of a NEW chapter in the chunk text, update the chapter.\n"
        "Otherwise, keep the current chapter provided in the user prompt.\n"
        "If unsure whether a new chapter starts, do NOT change the chapter.\n"
        "No markdown. No commentary.\n"
        "\n"
        "TRANSLATION OUTPUT RULES:\n"
        "- The translated text must preserve the original meaning and paragraph structure.\n"
        "- Lines that contain ONLY a page number (e.g., '12') surrounded by blank lines MUST be omitted.\n"
        "- Meaningful numbered items (e.g., '1. Introduction', references, equations, figure/table numbers) MUST be kept.\n"
        "\n"
        "FORMATTING REPAIR RULES (apply only if clearly needed):\n"
        "- If a TAB character (\\t) appears in the middle of a line and likely represents a broken line break,\n"
        "  replace it with a newline followed by a tab ('\\n\\t') in the translation.\n"
        "- Do NOT modify tabs that are clearly used for tables, code blocks, or aligned columns.\n"
        "- Do NOT intentionally add or remove paragraphs.\n"
        "\n\n"
        f"Tail of the previous chunk of source text (last 300 chars):\n{previous_tail}"
    ))

    return (
        "You are a professional book translator.\n"
        'Return STRICT JSON only: {"chapter": "...", "translation": "..."}.\n'
        'The "chapter" field MUST match the exact chapter key from the "Chapters Context".\n'
        "If you clearly detect the start of a NEW chapter in the chunk text, update the chapter.\n"
        "Otherwise, keep the current chapter provided in the user prompt.\n"
        "If unsure whether a new chapter starts, do NOT change the chapter.\n"
        "No markdown. No commentary.\n"
        "\n"
        "TRANSLATION OUTPUT RULES:\n"
        "- The translated text must preserve the original meaning and paragraph structure.\n"
        "- Lines that contain ONLY a page number (e.g., '12') surrounded by blank lines MUST be omitted.\n"
        "- Meaningful numbered items (e.g., '1. Introduction', references, equations, figure/table numbers) MUST be kept.\n"
        "\n"
        "FORMATTING REPAIR RULES (apply only if clearly needed):\n"
        "- If a TAB character (\\t) appears in the middle of a line and likely represents a broken line break,\n"
        "  replace it with a newline followed by a tab ('\\n\\t') in the translation.\n"
        "- Do NOT modify tabs that are clearly used for tables, code blocks, or aligned columns.\n"
        "- Do NOT intentionally add or remove paragraphs.\n"
        "\n\n"
        f"Tail of the previous chunk of source text (last 300 chars):\n{previous_tail}"
    )


def build_translation_user_prompt(
    chunk_text: str,
    target_language: str,
    current_chapter: Optional[str],
    context: Optional[Dict[str, Any]] = None,
) -> str:
    # 1) Build context block with dynamic chapter summaries
    context_parts = []

    if context:
        # Title & Author
        title = context.get("title")
        author = context.get("author(s)")
        if title and title != "not provided":
            context_parts.append(f"Title: {title}")
        if author and author != "not provided":
            context_parts.append(f"Author(s): {author}")

        # Global Summary
        summary = context.get("summary")
        if summary and summary != "not provided":
            context_parts.append(f"Book Summary: {summary}")

        # Dynamic Chapter List
        chapters = context.get("chapters")
        print("CHAPTERS --->", chapters)
        if isinstance(chapters, dict) and chapters:
            chapter_lines = []
            for ch_id, ch_data in chapters.items():
                print("CHAPTER ID:", ch_id, "\nCHAPTER DATA:", ch_data)
                if not isinstance(ch_data, dict):
                    continue

                # Check if this is the current chapter
                # Normalization: simple strip/lower check or direct match
                is_current = False
                if (
                    current_chapter
                    and str(ch_id).strip() == str(current_chapter).strip()
                ):
                    is_current = True

                desc = ch_data.get("detailed" if is_current else "general")
                if desc:
                    chapter_lines.append(f"- {ch_id} - {desc}")

            if chapter_lines:
                context_parts.append("Chapters Context:")
                context_parts.extend(chapter_lines)

    ctx_block = ""
    if context_parts:
        ctx_block = "Context:\n" + "\n".join(context_parts) + "\n\n"

    return (
        f"{ctx_block}"
        f"Target language: {target_language}\n"
        f"Current chapter (from previous chunk; keep unless a new chapter clearly starts): {current_chapter}\n\n"
        "TASK:\n"
        "1) Translate ONLY the text inside <TEXT_TO_TRANSLATE> ... </TEXT_TO_TRANSLATE>.\n"
        "2) Do NOT translate any other parts of this prompt (Context, Target language line, etc.).\n"
        "3) Return STRICT JSON only.\n\n"
        "<TEXT_TO_TRANSLATE>\n"
        f"{chunk_text}\n"
        "</TEXT_TO_TRANSLATE>\n\n"
        "Output JSON only."
    )
